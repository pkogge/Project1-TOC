Project x Readme Team cta
Version 1 9/11/24
A single copy of this template should be filled out and submitted with each project submission, regardless of the number of students on the team. It should have the name readme_”teamname”
Also change the title of this template to “Project x Readme Team xxx”
1	Team Name: cta
2	Team members names and netids
Net ids: 
-	Chau Ta: cta
-	Bae Rae: breh
3	Overall project attempted, with sub-projects:
SAT;
-	Bruteforce
-	Backtracking
4	Overall success of the project: Both SAT solvers work. 
5	Approximately total time (in hours) to complete: 5 
6	Link to github repository: https://github.com/cht-au/Project1-TOC
7	List of included files (if you have many files of a certain type, such as test files of different sizes, list just the folder): (Add more rows as necessary). Add more rows as necessary.

File/folder Name	File Contents and Use
Code Files
src/sat.py	SatSolver class with implemented sat_brutefroce and sat_backtrack
src/helpers/sat_solver_helper.py 	Read file, config problems, run solvers, and save results 
Test Files
input/cnffile.cnf	test cases for CNF
Output Files
result/brute_force_cnffile_sat_solver_results.csv
result/btracking_cnffile_sat_solver_results.csv	
Plots (as needed)
backtrack_graph.png	Time taken vs number of clauses
bruteforce_graph.png	Time taken vs number of clauses

8	Programming languages used, and associated libraries:
-	Python, intertools, and typing 
9	Key data structures (for each sub-project):
SAT_bruteforce: dictionary of assignments using itertools.product()
SAT_backtracking: dictionary of assignment using recursion
10	General operation of code (for each subproject)
SAT_bruteforce: use intertools to list out all possible combinations of n variables. Create a dictionary of those assignment and check if that assignment made satisfy every clause. If not try another dictionary of assignment until there’s no combination left

SAT_Backtracking: use recursion algorithm where the depth represents the variable number. Backtrack takes in the depth/variable index and the current assignment and return if that assignment is true and the assignment that it got. Every time backtrack() is called, do a for loop to assign variable for the current depth.
 
To make backtrack faster, we check if partial assignment works, if the partial assignment causes a clause to be false then undo the choice.

After checking partially, backtrack() calls itself to get True/False for the next depth/variable. Base case: if the depth is equal the number of variables, then check if that assignment make all the clauses true. If not then, delete the assignment. If true, then return True and the assignment.

If after checking both branches and nothing work, then return False, empty dictionary. 
11	What test cases you used/added, why you used them, what did they tell you about the correctness of your code.
We added a test case with 20 variables and 100 clauses that is one big implication chain to test if backtrack would prune early.
In the test, backtrack was much faster than brute force. Therefore, we know that backtrack actually works and can prune earlier than brute force
12	How you managed the code development: We tested codes on our local machine and sent snippets of functions. We then had one person commit and push everything
13	Detailed discussion of results:
For the testcases provided in the Github, both backtrack and brute force was able to solve the problem as consistent with the solution. They both had similar run-time, which is expected for low number of variables.
For the special testcase with many variables. Backtrack was much faster than brute force by pruning early.
14	How team was organized:
Both of us brainstorm how to implement the algorithm overall. Bae looked at how the file is parsed and implement helper functions, while Chau implement the main algorithm for solving SAT. 
15	What you might do differently if you did the project again: divide up the work so that each person do a solver function instead of helpers vs main functions
16	Any additional material:

